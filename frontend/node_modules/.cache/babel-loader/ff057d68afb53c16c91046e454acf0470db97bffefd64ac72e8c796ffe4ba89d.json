{"ast":null,"code":"/**\r\n * API Client Service\r\n * Task: T036 - Create API client service\r\n * \r\n * Service for communicating with the PR Summarizer backend API\r\n * with proper error handling, retry logic, and TypeScript types.\r\n */\n\n// ===== TYPES AND INTERFACES =====\n\n// ===== ERROR CLASSES =====\n\nexport class APIClientError extends Error {\n  constructor(message, statusCode, errorCode, correlationId, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.errorCode = errorCode;\n    this.correlationId = correlationId;\n    this.details = details;\n    this.name = 'APIClientError';\n  }\n}\nexport class ValidationAPIError extends APIClientError {\n  constructor(message, validationErrors, correlationId) {\n    super(message, 400, 'VALIDATION_ERROR', correlationId);\n    this.validationErrors = validationErrors;\n    this.name = 'ValidationAPIError';\n  }\n}\nexport class NetworkError extends APIClientError {\n  constructor(message, originalError) {\n    super(message, 0, 'NETWORK_ERROR');\n    this.originalError = originalError;\n    this.name = 'NetworkError';\n  }\n}\nexport class TimeoutError extends APIClientError {\n  constructor(message = 'Request timed out') {\n    super(message, 0, 'TIMEOUT_ERROR');\n    this.name = 'TimeoutError';\n  }\n}\n\n// ===== CONFIGURATION =====\n\nconst DEFAULT_CONFIG = {\n  baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000',\n  timeout: 30000,\n  // 30 seconds\n  retries: 3,\n  retryDelay: 1000,\n  // 1 second\n  retryBackoff: true,\n  enableLogging: process.env.NODE_ENV === 'development'\n};\n\n// ===== UTILITY FUNCTIONS =====\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst isRetryableError = error => {\n  if (!error.statusCode) return true; // Network errors\n  return error.statusCode >= 500 || error.statusCode === 429; // Server errors or rate limiting\n};\nconst log = (message, data) => {\n  if (DEFAULT_CONFIG.enableLogging) {\n    console.log(`[APIClient] ${message}`, data || '');\n  }\n};\n\n// ===== MAIN API CLIENT CLASS =====\n\nexport class APIClient {\n  constructor(config = {}) {\n    this.config = void 0;\n    this.abortController = null;\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n    log('API Client initialized', {\n      baseURL: this.config.baseURL\n    });\n  }\n\n  /**\r\n   * Update client configuration\r\n   */\n  updateConfig(config) {\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    log('Configuration updated', config);\n  }\n\n  /**\r\n   * Cancel ongoing requests\r\n   */\n  cancelRequests() {\n    if (this.abortController) {\n      this.abortController.abort();\n      this.abortController = null;\n      log('Requests cancelled');\n    }\n  }\n\n  /**\r\n   * Core HTTP request method with retry logic\r\n   */\n  async request(endpoint, options = {}, retryCount = 0) {\n    const url = `${this.config.baseURL}${endpoint}`;\n\n    // Create new abort controller for this request\n    this.abortController = new AbortController();\n    const requestOptions = {\n      ...options,\n      signal: this.abortController.signal,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        ...options.headers\n      }\n    };\n    log(`${options.method || 'GET'} ${endpoint}`, {\n      attempt: retryCount + 1,\n      maxRetries: this.config.retries\n    });\n    try {\n      // Create timeout promise\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new TimeoutError()), this.config.timeout);\n      });\n\n      // Make the request with timeout\n      const response = await Promise.race([fetch(url, requestOptions), timeoutPromise]);\n\n      // Handle HTTP errors\n      if (!response.ok) {\n        const errorData = await this.parseErrorResponse(response);\n        throw this.createAPIError(response.status, errorData);\n      }\n\n      // Parse successful response\n      const data = await response.json();\n      log(`${options.method || 'GET'} ${endpoint} - Success`);\n      return data;\n    } catch (error) {\n      // Handle abort\n      if (error instanceof Error && error.name === 'AbortError') {\n        log(`${options.method || 'GET'} ${endpoint} - Aborted`);\n        throw new APIClientError('Request was cancelled', 0, 'CANCELLED');\n      }\n\n      // Handle timeout\n      if (error instanceof TimeoutError) {\n        log(`${options.method || 'GET'} ${endpoint} - Timeout`);\n      }\n\n      // Handle network errors\n      if (error instanceof TypeError && error.message.includes('fetch')) {\n        const networkError = new NetworkError('Network error - please check your connection', error);\n        log(`${options.method || 'GET'} ${endpoint} - Network Error`, error.message);\n        throw networkError;\n      }\n\n      // Retry logic for retryable errors\n      if (error instanceof APIClientError && retryCount < this.config.retries && isRetryableError(error)) {\n        const delay = this.config.retryBackoff ? this.config.retryDelay * Math.pow(2, retryCount) : this.config.retryDelay;\n        log(`${options.method || 'GET'} ${endpoint} - Retrying after ${delay}ms`, {\n          error: error.message,\n          attempt: retryCount + 1\n        });\n        await sleep(delay);\n        return this.request(endpoint, options, retryCount + 1);\n      }\n\n      // Re-throw non-retryable or max-retry-reached errors\n      log(`${options.method || 'GET'} ${endpoint} - Failed`, error);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Parse error response from API\r\n   */\n  async parseErrorResponse(response) {\n    try {\n      const errorData = await response.json();\n      return errorData;\n    } catch {\n      // Fallback for non-JSON error responses\n      return {\n        error: 'HTTP Error',\n        message: `HTTP ${response.status} - ${response.statusText}`,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\r\n   * Create appropriate error instance based on response\r\n   */\n  createAPIError(statusCode, errorData) {\n    if (statusCode === 400 && 'errors' in errorData) {\n      return new ValidationAPIError(errorData.message, errorData.errors, errorData.correlation_id);\n    }\n    return new APIClientError(errorData.message, statusCode, errorData.error, errorData.correlation_id, errorData.details);\n  }\n\n  // ===== PUBLIC API METHODS =====\n\n  /**\r\n   * Generate PR summary\r\n   */\n  async generateSummary(request) {\n    var _request$jiraTicketId;\n    const cleanRequest = {\n      github_pr_url: request.githubPrUrl.trim(),\n      jira_ticket_id: ((_request$jiraTicketId = request.jiraTicketId) === null || _request$jiraTicketId === void 0 ? void 0 : _request$jiraTicketId.trim()) || undefined\n    };\n    return this.request('/api/v1/summary/generate', {\n      method: 'POST',\n      body: JSON.stringify(cleanRequest)\n    });\n  }\n\n  /**\r\n   * Start asynchronous summary generation\r\n   */\n  async generateSummaryAsync(request) {\n    var _request$jiraTicketId2;\n    const cleanRequest = {\n      github_pr_url: request.githubPrUrl.trim(),\n      jira_ticket_id: ((_request$jiraTicketId2 = request.jiraTicketId) === null || _request$jiraTicketId2 === void 0 ? void 0 : _request$jiraTicketId2.trim()) || undefined\n    };\n    return this.request('/api/v1/summary/generate-async', {\n      method: 'POST',\n      body: JSON.stringify(cleanRequest)\n    });\n  }\n\n  /**\r\n   * Check service health\r\n   */\n  async getHealth() {\n    return this.request('/api/v1/summary/health');\n  }\n\n  /**\r\n   * Get service metrics\r\n   */\n  async getMetrics() {\n    return this.request('/api/v1/summary/metrics');\n  }\n\n  /**\r\n   * Basic health check (minimal endpoint)\r\n   */\n  async ping() {\n    return this.request('/health');\n  }\n}\n\n// ===== SINGLETON INSTANCE =====\n\nlet apiClientInstance = null;\n\n/**\r\n * Get or create API client singleton\r\n */\nexport const getAPIClient = config => {\n  if (!apiClientInstance) {\n    apiClientInstance = new APIClient(config);\n  } else if (config) {\n    apiClientInstance.updateConfig(config);\n  }\n  return apiClientInstance;\n};\n\n/**\r\n * Reset API client singleton (useful for testing)\r\n */\nexport const resetAPIClient = () => {\n  if (apiClientInstance) {\n    apiClientInstance.cancelRequests();\n  }\n  apiClientInstance = null;\n};\n\n// ===== CONVENIENCE FUNCTIONS =====\n\n/**\r\n * Quick summary generation with default client\r\n */\nexport const generateSummary = async request => {\n  const client = getAPIClient();\n  return client.generateSummary(request);\n};\n\n/**\r\n * Quick health check with default client\r\n */\nexport const checkHealth = async () => {\n  const client = getAPIClient();\n  return client.getHealth();\n};\n\n/**\r\n * Quick service metrics with default client\r\n */\nexport const getServiceMetrics = async () => {\n  const client = getAPIClient();\n  return client.getMetrics();\n};\n\n// ===== REACT HOOKS (BONUS) =====\n\n/**\r\n * React hook for API client (if used in React context)\r\n */\nexport const useAPIClient = config => {\n  return getAPIClient(config);\n};\n\n// ===== EXPORTS =====\n\nexport default APIClient;","map":{"version":3,"names":["APIClientError","Error","constructor","message","statusCode","errorCode","correlationId","details","name","ValidationAPIError","validationErrors","NetworkError","originalError","TimeoutError","DEFAULT_CONFIG","baseURL","process","env","REACT_APP_API_BASE_URL","timeout","retries","retryDelay","retryBackoff","enableLogging","NODE_ENV","sleep","ms","Promise","resolve","setTimeout","isRetryableError","error","log","data","console","APIClient","config","abortController","updateConfig","cancelRequests","abort","request","endpoint","options","retryCount","url","AbortController","requestOptions","signal","headers","method","attempt","maxRetries","timeoutPromise","_","reject","response","race","fetch","ok","errorData","parseErrorResponse","createAPIError","status","json","TypeError","includes","networkError","delay","Math","pow","statusText","timestamp","Date","toISOString","errors","correlation_id","generateSummary","_request$jiraTicketId","cleanRequest","github_pr_url","githubPrUrl","trim","jira_ticket_id","jiraTicketId","undefined","body","JSON","stringify","generateSummaryAsync","_request$jiraTicketId2","getHealth","getMetrics","ping","apiClientInstance","getAPIClient","resetAPIClient","client","checkHealth","getServiceMetrics","useAPIClient"],"sources":["C:/Repo/PR_Summarizer/frontend/src/services/api.ts"],"sourcesContent":["/**\r\n * API Client Service\r\n * Task: T036 - Create API client service\r\n * \r\n * Service for communicating with the PR Summarizer backend API\r\n * with proper error handling, retry logic, and TypeScript types.\r\n */\r\n\r\n// ===== TYPES AND INTERFACES =====\r\n\r\nexport interface SummaryRequest {\r\n  githubPrUrl: string;\r\n  jiraTicketId?: string;\r\n}\r\n\r\nexport interface PRSummary {\r\n  id: string;\r\n  request_id?: string;\r\n  github_pr_url: string;\r\n  jira_ticket_id?: string;\r\n  business_context: string;\r\n  code_change_summary: string;\r\n  business_code_impact: string;\r\n  suggested_test_cases: string[];\r\n  risk_complexity: string;\r\n  reviewer_guidance: string;\r\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';\r\n  created_at: string;\r\n  processing_time_ms?: number;\r\n}\r\n\r\nexport interface APIError {\r\n  error: string;\r\n  message: string;\r\n  timestamp: string;\r\n  correlation_id?: string;\r\n  path?: string;\r\n  method?: string;\r\n  details?: Record<string, any>;\r\n}\r\n\r\nexport interface ValidationError extends APIError {\r\n  errors: Array<{\r\n    field: string;\r\n    message: string;\r\n    code: string;\r\n    value?: any;\r\n  }>;\r\n}\r\n\r\nexport interface AsyncTaskResponse {\r\n  task_id: string;\r\n  status: string;\r\n  message: string;\r\n}\r\n\r\nexport interface HealthStatus {\r\n  status: 'healthy' | 'unhealthy';\r\n  timestamp: string;\r\n  services?: Record<string, string>;\r\n  version?: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface ServiceMetrics {\r\n  timestamp: string;\r\n  metrics: {\r\n    performance: {\r\n      total_summaries_generated: number;\r\n      average_processing_time_ms: number;\r\n      success_rate: number;\r\n    };\r\n    health: {\r\n      service_initialized: boolean;\r\n      dependencies_count: number;\r\n      uptime_seconds: number;\r\n    };\r\n  };\r\n  status: string;\r\n}\r\n\r\n// ===== ERROR CLASSES =====\r\n\r\nexport class APIClientError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public statusCode?: number,\r\n    public errorCode?: string,\r\n    public correlationId?: string,\r\n    public details?: Record<string, any>\r\n  ) {\r\n    super(message);\r\n    this.name = 'APIClientError';\r\n  }\r\n}\r\n\r\nexport class ValidationAPIError extends APIClientError {\r\n  constructor(\r\n    message: string,\r\n    public validationErrors: ValidationError['errors'],\r\n    correlationId?: string\r\n  ) {\r\n    super(message, 400, 'VALIDATION_ERROR', correlationId);\r\n    this.name = 'ValidationAPIError';\r\n  }\r\n}\r\n\r\nexport class NetworkError extends APIClientError {\r\n  constructor(message: string, public originalError?: Error) {\r\n    super(message, 0, 'NETWORK_ERROR');\r\n    this.name = 'NetworkError';\r\n  }\r\n}\r\n\r\nexport class TimeoutError extends APIClientError {\r\n  constructor(message: string = 'Request timed out') {\r\n    super(message, 0, 'TIMEOUT_ERROR');\r\n    this.name = 'TimeoutError';\r\n  }\r\n}\r\n\r\n// ===== CONFIGURATION =====\r\n\r\nexport interface APIClientConfig {\r\n  baseURL?: string;\r\n  timeout?: number;\r\n  retries?: number;\r\n  retryDelay?: number;\r\n  retryBackoff?: boolean;\r\n  enableLogging?: boolean;\r\n}\r\n\r\nconst DEFAULT_CONFIG: Required<APIClientConfig> = {\r\n  baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000',\r\n  timeout: 30000, // 30 seconds\r\n  retries: 3,\r\n  retryDelay: 1000, // 1 second\r\n  retryBackoff: true,\r\n  enableLogging: process.env.NODE_ENV === 'development',\r\n};\r\n\r\n// ===== UTILITY FUNCTIONS =====\r\n\r\nconst sleep = (ms: number): Promise<void> => \r\n  new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nconst isRetryableError = (error: APIClientError): boolean => {\r\n  if (!error.statusCode) return true; // Network errors\r\n  return error.statusCode >= 500 || error.statusCode === 429; // Server errors or rate limiting\r\n};\r\n\r\nconst log = (message: string, data?: any) => {\r\n  if (DEFAULT_CONFIG.enableLogging) {\r\n    console.log(`[APIClient] ${message}`, data || '');\r\n  }\r\n};\r\n\r\n// ===== MAIN API CLIENT CLASS =====\r\n\r\nexport class APIClient {\r\n  private config: Required<APIClientConfig>;\r\n  private abortController: AbortController | null = null;\r\n\r\n  constructor(config: APIClientConfig = {}) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    log('API Client initialized', { baseURL: this.config.baseURL });\r\n  }\r\n\r\n  /**\r\n   * Update client configuration\r\n   */\r\n  updateConfig(config: Partial<APIClientConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n    log('Configuration updated', config);\r\n  }\r\n\r\n  /**\r\n   * Cancel ongoing requests\r\n   */\r\n  cancelRequests(): void {\r\n    if (this.abortController) {\r\n      this.abortController.abort();\r\n      this.abortController = null;\r\n      log('Requests cancelled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Core HTTP request method with retry logic\r\n   */\r\n  private async request<T>(\r\n    endpoint: string,\r\n    options: RequestInit = {},\r\n    retryCount = 0\r\n  ): Promise<T> {\r\n    const url = `${this.config.baseURL}${endpoint}`;\r\n    \r\n    // Create new abort controller for this request\r\n    this.abortController = new AbortController();\r\n    \r\n    const requestOptions: RequestInit = {\r\n      ...options,\r\n      signal: this.abortController.signal,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Accept': 'application/json',\r\n        ...options.headers,\r\n      },\r\n    };\r\n\r\n    log(`${options.method || 'GET'} ${endpoint}`, { \r\n      attempt: retryCount + 1,\r\n      maxRetries: this.config.retries \r\n    });\r\n\r\n    try {\r\n      // Create timeout promise\r\n      const timeoutPromise = new Promise<never>((_, reject) => {\r\n        setTimeout(() => reject(new TimeoutError()), this.config.timeout);\r\n      });\r\n\r\n      // Make the request with timeout\r\n      const response = await Promise.race([\r\n        fetch(url, requestOptions),\r\n        timeoutPromise\r\n      ]);\r\n\r\n      // Handle HTTP errors\r\n      if (!response.ok) {\r\n        const errorData = await this.parseErrorResponse(response);\r\n        throw this.createAPIError(response.status, errorData);\r\n      }\r\n\r\n      // Parse successful response\r\n      const data = await response.json();\r\n      log(`${options.method || 'GET'} ${endpoint} - Success`);\r\n      return data;\r\n\r\n    } catch (error) {\r\n      // Handle abort\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        log(`${options.method || 'GET'} ${endpoint} - Aborted`);\r\n        throw new APIClientError('Request was cancelled', 0, 'CANCELLED');\r\n      }\r\n\r\n      // Handle timeout\r\n      if (error instanceof TimeoutError) {\r\n        log(`${options.method || 'GET'} ${endpoint} - Timeout`);\r\n      }\r\n\r\n      // Handle network errors\r\n      if (error instanceof TypeError && error.message.includes('fetch')) {\r\n        const networkError = new NetworkError(\r\n          'Network error - please check your connection',\r\n          error\r\n        );\r\n        log(`${options.method || 'GET'} ${endpoint} - Network Error`, error.message);\r\n        throw networkError;\r\n      }\r\n\r\n      // Retry logic for retryable errors\r\n      if (error instanceof APIClientError && \r\n          retryCount < this.config.retries && \r\n          isRetryableError(error)) {\r\n        \r\n        const delay = this.config.retryBackoff \r\n          ? this.config.retryDelay * Math.pow(2, retryCount)\r\n          : this.config.retryDelay;\r\n\r\n        log(`${options.method || 'GET'} ${endpoint} - Retrying after ${delay}ms`, {\r\n          error: error.message,\r\n          attempt: retryCount + 1\r\n        });\r\n\r\n        await sleep(delay);\r\n        return this.request<T>(endpoint, options, retryCount + 1);\r\n      }\r\n\r\n      // Re-throw non-retryable or max-retry-reached errors\r\n      log(`${options.method || 'GET'} ${endpoint} - Failed`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse error response from API\r\n   */\r\n  private async parseErrorResponse(response: Response): Promise<APIError | ValidationError> {\r\n    try {\r\n      const errorData = await response.json();\r\n      return errorData;\r\n    } catch {\r\n      // Fallback for non-JSON error responses\r\n      return {\r\n        error: 'HTTP Error',\r\n        message: `HTTP ${response.status} - ${response.statusText}`,\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create appropriate error instance based on response\r\n   */\r\n  private createAPIError(statusCode: number, errorData: APIError | ValidationError): APIClientError {\r\n    if (statusCode === 400 && 'errors' in errorData) {\r\n      return new ValidationAPIError(\r\n        errorData.message,\r\n        errorData.errors,\r\n        errorData.correlation_id\r\n      );\r\n    }\r\n\r\n    return new APIClientError(\r\n      errorData.message,\r\n      statusCode,\r\n      errorData.error,\r\n      errorData.correlation_id,\r\n      errorData.details\r\n    );\r\n  }\r\n\r\n  // ===== PUBLIC API METHODS =====\r\n\r\n  /**\r\n   * Generate PR summary\r\n   */\r\n  async generateSummary(request: SummaryRequest): Promise<PRSummary> {\r\n    const cleanRequest = {\r\n      github_pr_url: request.githubPrUrl.trim(),\r\n      jira_ticket_id: request.jiraTicketId?.trim() || undefined,\r\n    };\r\n\r\n    return this.request<PRSummary>('/api/v1/summary/generate', {\r\n      method: 'POST',\r\n      body: JSON.stringify(cleanRequest),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start asynchronous summary generation\r\n   */\r\n  async generateSummaryAsync(request: SummaryRequest): Promise<AsyncTaskResponse> {\r\n    const cleanRequest = {\r\n      github_pr_url: request.githubPrUrl.trim(),\r\n      jira_ticket_id: request.jiraTicketId?.trim() || undefined,\r\n    };\r\n\r\n    return this.request<AsyncTaskResponse>('/api/v1/summary/generate-async', {\r\n      method: 'POST',\r\n      body: JSON.stringify(cleanRequest),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check service health\r\n   */\r\n  async getHealth(): Promise<HealthStatus> {\r\n    return this.request<HealthStatus>('/api/v1/summary/health');\r\n  }\r\n\r\n  /**\r\n   * Get service metrics\r\n   */\r\n  async getMetrics(): Promise<ServiceMetrics> {\r\n    return this.request<ServiceMetrics>('/api/v1/summary/metrics');\r\n  }\r\n\r\n  /**\r\n   * Basic health check (minimal endpoint)\r\n   */\r\n  async ping(): Promise<{ status: string; service: string; timestamp: string }> {\r\n    return this.request('/health');\r\n  }\r\n}\r\n\r\n// ===== SINGLETON INSTANCE =====\r\n\r\nlet apiClientInstance: APIClient | null = null;\r\n\r\n/**\r\n * Get or create API client singleton\r\n */\r\nexport const getAPIClient = (config?: APIClientConfig): APIClient => {\r\n  if (!apiClientInstance) {\r\n    apiClientInstance = new APIClient(config);\r\n  } else if (config) {\r\n    apiClientInstance.updateConfig(config);\r\n  }\r\n  return apiClientInstance;\r\n};\r\n\r\n/**\r\n * Reset API client singleton (useful for testing)\r\n */\r\nexport const resetAPIClient = (): void => {\r\n  if (apiClientInstance) {\r\n    apiClientInstance.cancelRequests();\r\n  }\r\n  apiClientInstance = null;\r\n};\r\n\r\n// ===== CONVENIENCE FUNCTIONS =====\r\n\r\n/**\r\n * Quick summary generation with default client\r\n */\r\nexport const generateSummary = async (request: SummaryRequest): Promise<PRSummary> => {\r\n  const client = getAPIClient();\r\n  return client.generateSummary(request);\r\n};\r\n\r\n/**\r\n * Quick health check with default client\r\n */\r\nexport const checkHealth = async (): Promise<HealthStatus> => {\r\n  const client = getAPIClient();\r\n  return client.getHealth();\r\n};\r\n\r\n/**\r\n * Quick service metrics with default client\r\n */\r\nexport const getServiceMetrics = async (): Promise<ServiceMetrics> => {\r\n  const client = getAPIClient();\r\n  return client.getMetrics();\r\n};\r\n\r\n// ===== REACT HOOKS (BONUS) =====\r\n\r\n/**\r\n * React hook for API client (if used in React context)\r\n */\r\nexport const useAPIClient = (config?: APIClientConfig): APIClient => {\r\n  return getAPIClient(config);\r\n};\r\n\r\n// ===== EXPORTS =====\r\n\r\nexport default APIClient;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}